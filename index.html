<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL Alphabet Recognition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles to ensure video and canvas overlay properly */
        #video-container {
            position: relative;
            width: fit-content;
            margin: 0 auto;
        }
        #output-canvas {
            position: absolute;
            left: 0;
            top: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <h1 class="text-4xl font-bold text-center mb-8">ASL Alphabet Recognition</h1>

        <!-- Controls -->
        <div class="flex justify-center gap-4 mb-6">
            <button id="start-btn" class="bg-green-600 hover:bg-green-700 px-6 py-2 rounded-lg font-semibold transition-colors">
                Start Camera
            </button>
            <button id="stop-btn" class="hidden bg-red-600 hover:bg-red-700 px-6 py-2 rounded-lg font-semibold transition-colors">
                Stop Camera
            </button>
        </div>

        <!-- Status Text -->
        <p id="loading-text" class="text-center text-gray-300 mb-6">Loading models...</p>

        <!-- Video Container -->
        <div id="video-container" class="hidden mb-8">
            <video id="webcam" autoplay playsinline class="rounded-lg"></video>
            <canvas id="output-canvas" class="rounded-lg"></canvas>
        </div>

        <!-- Prediction Display -->
        <div class="text-center">
            <p id="prediction-text" class="text-8xl font-bold text-green-500">---</p>
        </div>
    </div>

    <script type="module">
        // Import MediaPipe dependencies
        import { HandLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/dist/vision_bundle.js';

        // Global variables
        let handLandmarker = null;
        let classifier = null;
        let video = null;
        let canvas = null;
        let ctx = null;
        let predictLoopId = null;

        // Helper Functions
        // --- Start of Helper Functions ---

        // 1. Normalization Logic (Ported from Python)
        function normalizeLandmarks(landmarks) {
            let coords = [];
            for (const landmark of landmarks) {
                coords.push(landmark.x, landmark.y, landmark.z);
            }
            coords = new Float32Array(coords); // 63 elements

            const root = [coords[0], coords[1], coords[2]];
            for (let i = 0; i < 21; i++) {
                coords[i * 3]     -= root[0]; // x
                coords[i * 3 + 1] -= root[1]; // y
                coords[i * 3 + 2] -= root[2]; // z
            }

            const middleFingerBase = [coords[9 * 3], coords[9 * 3 + 1], coords[9 * 3 + 2]];
            const scaleFactor = Math.sqrt(
                middleFingerBase[0] ** 2 + middleFingerBase[1] ** 2 + middleFingerBase[2] ** 2
            );
            if (scaleFactor === 0) return null;

            for (let i = 0; i < 63; i++) {
                coords[i] /= scaleFactor;
            }
            
            return coords; // Return the 63-element flat array
        }

        // 2. Random Forest Prediction Logic (Reads the JSON)
        function predictWithRF(features) {
            const totalVotes = new Array(classifier.n_classes).fill(0);
            
            // Helper to find the index of the max value
            const argmax = (arr) => {
                if (arr.length === 0) return -1;
                let max = arr[0];
                let maxIndex = 0;
                for (let i = 1; i < arr.length; i++) {
                    if (arr[i] > max) {
                        maxIndex = i;
                        max = arr[i];
                    }
                }
                return maxIndex;
            };

            for (const tree of classifier.trees) {
                let nodeIndex = 0;
                while (tree.children_left[nodeIndex] !== -1) {
                    const featureIndex = tree.feature[nodeIndex];
                    const threshold = tree.threshold[nodeIndex];
                    if (features[featureIndex] <= threshold) {
                        nodeIndex = tree.children_left[nodeIndex];
                    } else {
                        nodeIndex = tree.children_right[nodeIndex];
                    }
                }
                const leafVotes = tree.value[nodeIndex][0];
                const winningClassIndex = argmax(leafVotes);
                totalVotes[winningClassIndex]++;
            }

            const finalPredictionIndex = argmax(totalVotes);
            const prediction = classifier.classes[finalPredictionIndex];
            return prediction;
        }

        // 3. Smoothing Logic (Fixes flicker for A/M/N/S)
        const SMOOTHING_BUFFER_SIZE = 10;
        const predictionBuffer = [];

        function applySmoothing(prediction) {
            predictionBuffer.push(prediction);
            if (predictionBuffer.length > SMOOTHING_BUFFER_SIZE) {
                predictionBuffer.shift();
            }
            
            const counts = {};
            let maxCount = 0;
            let mode = "---";
            
            for (const pred of predictionBuffer) {
                if (pred === null) continue;
                counts[pred] = (counts[pred] || 0) + 1;
                if (counts[pred] > maxCount) {
                    maxCount = counts[pred];
                    mode = pred;
                }
            }
            return mode;
        }

        // --- End of Helper Functions ---

        // Load classifier model from JSON
        async function loadClassifier() {
            try {
                const response = await fetch('asl_classifier_model.json');
                classifier = await response.json();
                return true;
            } catch (error) {
                console.error('Error loading classifier:', error);
                return false;
            }
        }

        // Initialize MediaPipe HandLandmarker
        async function createHandLandmarker() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm'
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                        delegate: 'GPU'
                    },
                    runningMode: 'VIDEO',
                    numHands: 1
                });
                return true;
            } catch (error) {
                console.error('Error creating HandLandmarker:', error);
                return false;
            }
        }

        // Main prediction loop
        function predictWebcam() {
            if (!handLandmarker || !video || !canvas) {
                predictLoopId = requestAnimationFrame(predictWebcam);
                return;
            }

            let startTimeMs = performance.now();
            const results = handLandmarker.detectForVideo(video, startTimeMs);

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.landmarks && results.landmarks.length > 0) {
                // Draw hand skeleton
                handLandmarker.draw(canvas, results);

                // Process landmarks and predict
                const normalizedLandmarks = normalizeLandmarks(results.landmarks[0]);
                if (normalizedLandmarks) {
                    const rawPrediction = predictWithRF(normalizedLandmarks);
                    const smoothedPrediction = applySmoothing(rawPrediction);
                    document.getElementById('prediction-text').textContent = smoothedPrediction;
                }
            } else {
                const smoothedPrediction = applySmoothing(null);
                document.getElementById('prediction-text').textContent = smoothedPrediction;
            }

            predictLoopId = requestAnimationFrame(predictWebcam);
        }

        // Initialize video and canvas
        function initializeVideoCanvas() {
            video = document.getElementById('webcam');
            canvas = document.getElementById('output-canvas');
            ctx = canvas.getContext('2d');

            // Set up video event listener
            video.addEventListener('loadedmetadata', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            });
        }

        // Button click handlers
        async function startCamera() {
            try {
                document.getElementById('loading-text').textContent = 'Starting camera...';
                // Check for camera permissions
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Camera access is not supported by this browser');
                }

                // Request camera permission explicitly
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    },
                    audio: false
                });

                video.srcObject = stream;
                await video.play();

                document.getElementById('video-container').classList.remove('hidden');
                document.getElementById('start-btn').classList.add('hidden');
                document.getElementById('stop-btn').classList.remove('hidden');
                document.getElementById('loading-text').textContent = 'Camera active';

                predictWebcam();
            } catch (error) {
                console.error('Error starting camera:', error);
                document.getElementById('loading-text').textContent = 
                    error.name === 'NotAllowedError' ? 
                        'Camera access denied. Please allow camera access and try again.' : 
                        `Error starting camera: ${error.message}`;
            }
        }

        function stopCamera() {
            if (predictLoopId) {
                cancelAnimationFrame(predictLoopId);
                predictLoopId = null;
            }

            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }

            document.getElementById('video-container').classList.add('hidden');
            document.getElementById('start-btn').classList.remove('hidden');
            document.getElementById('stop-btn').classList.add('hidden');
            document.getElementById('prediction-text').textContent = '---';
            document.getElementById('loading-text').textContent = 'Camera off';
        }

        // Main initialization
        async function main() {
            document.getElementById('loading-text').textContent = 'Loading models...';

            // Initialize video and canvas elements
            initializeVideoCanvas();

            // Load models
            const [classifierLoaded, handLandmarkerLoaded] = await Promise.all([
                loadClassifier(),
                createHandLandmarker()
            ]);

            if (!classifierLoaded || !handLandmarkerLoaded) {
                document.getElementById('loading-text').textContent = 'Error loading models';
                return;
            }

            // Set up button listeners
            document.getElementById('start-btn').addEventListener('click', startCamera);
            document.getElementById('stop-btn').addEventListener('click', stopCamera);

            document.getElementById('loading-text').textContent = 'Ready to start';
        }

        // Start the application
        window.addEventListener('load', main);
    </script>
</body>
</html>